import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { SEO } from '@/components/SEO';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { AlertCircle, CheckCircle2, Loader2, Copy, RotateCcw, Sparkles, ArrowLeft } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import ReactMarkdown from 'react-markdown';
import { cn } from '@/lib/utils';

// Storage key for API key
const GEMINI_API_KEY_STORAGE_KEY = 'gemini_api_key';

interface Category {
  id: number;
  name: string;
  description: string;
  icon: string;
}

const InterviewQuestionsPractice: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { toast } = useToast();

  // State management
  const [apiKey, setApiKey] = useState<string>('');
  const [isVerified, setIsVerified] = useState<boolean>(false);
  const [isVerifying, setIsVerifying] = useState<boolean>(false);
  const [rememberKey, setRememberKey] = useState<boolean>(false);
  const [showApiKeyInput, setShowApiKeyInput] = useState<boolean>(true);
  const [categories, setCategories] = useState<Category[]>([]);
  
  // Get question and category from URL params
  const questionFromUrl = searchParams.get('question') || '';
  const categoryFromUrl = searchParams.get('category') || '';
  
  // Initialize state with URL parameters if they exist
  const [selectedCategory, setSelectedCategory] = useState<string>('');
  const [question, setQuestion] = useState<string>(questionFromUrl);
  
  // Update selectedCategory when categoryFromUrl changes
  useEffect(() => {
    if (categoryFromUrl) {
      setSelectedCategory(categoryFromUrl);
    }
  }, [categoryFromUrl]);
  const [answer, setAnswer] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const CHARACTER_LIMIT = 1000;

  // Load categories
  useEffect(() => {
    // Example categories - in a real app, you might fetch these from an API
    const exampleCategories: Category[] = [
      { id: 1, name: 'Product Strategy', description: 'Questions about product vision and strategy', icon: 'target' },
      { id: 2, name: 'Product Design', description: 'Questions about UX/UI and design', icon: 'palette' },
      { id: 3, name: 'Analytics', description: 'Questions about metrics and data analysis', icon: 'bar-chart' },
      { id: 4, name: 'Technical', description: 'Technical product management questions', icon: 'code' },
      { id: 5, name: 'Behavioral', description: 'Behavioral interview questions', icon: 'users' },
      { id: 6, name: 'RCA', description: 'Root cause analysis questions', icon: 'search' },
      { id: 7, name: 'Others', description: 'Other product management questions', icon: 'grid' },
    ];
    
    setCategories(exampleCategories);
  }, []);

  // Check for stored API key on mount
  useEffect(() => {
    const storedKey = localStorage.getItem(GEMINI_API_KEY_STORAGE_KEY) ||
                     sessionStorage.getItem(GEMINI_API_KEY_STORAGE_KEY);
    if (storedKey) {
      setApiKey(storedKey);
      verifyApiKey(storedKey, true);
    }
  }, [verifyApiKey]);

  // Suppress message channel errors from browser extensions
  useEffect(() => {
    const handleError = (event: ErrorEvent) => {
      // Suppress "message channel closed" errors from browser extensions
      if (event.message && event.message.includes('message channel closed')) {
        event.preventDefault();
        return true;
      }
      return false;
    };

    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      // Suppress "message channel closed" errors from browser extensions
      if (event.reason && event.reason.message && event.reason.message.includes('message channel closed')) {
        event.preventDefault();
        return true;
      }
      return false;
    };

    window.addEventListener('error', handleError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    return () => {
      window.removeEventListener('error', handleError);
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
    };
  }, []);

  // Verify API key function
  const verifyApiKey = useCallback(async (key: string, silent: boolean = false) => {
    if (!key) return false;

    setIsVerifying(true);
    setError(null);

    try {
      // In a real app, you would verify the API key with your backend
      // For now, we'll just simulate a successful verification
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      setIsVerified(true);
      setShowApiKeyInput(false);
      
      if (rememberKey) {
        localStorage.setItem(GEMINI_API_KEY_STORAGE_KEY, key);
      } else {
        sessionStorage.setItem(GEMINI_API_KEY_STORAGE_KEY, key);
      }
      
      if (!silent) {
        toast({
          title: 'Success',
          description: 'API key verified successfully!',
        });
      }
      return true;
    } catch (err) {
      console.error('Error verifying API key:', err);
      setIsVerified(false);
      setShowApiKeyInput(true);
      
      if (!silent) {
        toast({
          title: 'Error',
          description: 'Failed to verify API key. Please check and try again.',
          variant: 'destructive',
        });
      }
      return false;
    } finally {
      setIsVerifying(false);
    }
  }, [rememberKey, toast]);

  const handleVerifyClick = useCallback(async () => {
    await verifyApiKey(apiKey);
  }, [apiKey, verifyApiKey]);

  const clearApiKey = useCallback(() => {
    setApiKey('');
    setIsVerified(false);
    setShowApiKeyInput(true);
    localStorage.removeItem(GEMINI_API_KEY_STORAGE_KEY);
    sessionStorage.removeItem(GEMINI_API_KEY_STORAGE_KEY);
    toast({
      title: 'API Key Cleared',
      description: 'Your API key has been cleared.',
    });
  }, [toast]);

  const updateQuestionAnswer = async (id: number, data: { text: string; model: string; generated_at: string }) => {
    // In a real app, you would make an API call to update the question answer
    console.log('Updating question answer:', { id, data });
    // Simulate API call
    return new Promise<void>((resolve) => {
      setTimeout(() => resolve(), 500);
    });
  };

  const askAI = useCallback(async () => {
    if (!question.trim()) {
      setError('Please enter a question.');
      return;
    }
    
    if (!selectedCategory) {
      setError('Please select a category.');
      return;
    }

    if (question.length > CHARACTER_LIMIT) {
      setError(`Question exceeds ${CHARACTER_LIMIT} character limit.`);
      return;
    }

    setIsLoading(true);
    setError(null);
    setAnswer(null);

    try {
      const apiKey = localStorage.getItem(GEMINI_API_KEY_STORAGE_KEY) || 
                     sessionStorage.getItem(GEMINI_API_KEY_STORAGE_KEY);
      
      if (!apiKey) {
        throw new Error('No API key found. Please provide a Gemini API key.');
      }
      
      // Get question ID from URL params (if exists)
      const questionId = searchParams.get('id');

      // Create the system prompt with category-specific guidance
      let categoryGuidance = '';

      if (selectedCategory === 'RCA') {
        categoryGuidance = `
For Root Cause Analysis questions, focus on:
- Systematic debugging methodology (5 Whys, Fishbone diagram)
- Data-driven investigation approach
- Hypothesis formation and testing
- Communication with stakeholders during incidents
- Prevention strategies and post-mortem analysis`;
      } else if (selectedCategory === 'Others') {
        categoryGuidance = `
For general PM questions, adapt your answer to the specific topic:
- Identify the core PM skill being tested
- Use relevant frameworks and methodologies
- Provide concrete examples from PM practice
- Show strategic thinking and user empathy`;
      } else {
        categoryGuidance = `
Relevant PM frameworks to apply (e.g., CIRCLES, AARM, STAR)`;
      }

      const systemPrompt = `You are an experienced Product Manager interviewer helping candidates prepare for PM interviews.

Category: ${selectedCategory}
Question: ${question}

Please provide a comprehensive, structured answer following this format:

## Approach
How to think about this question

## Frameworks
${categoryGuidance}

## Example Answer
A detailed sample response

## Key Takeaways
- Bullet point 1
- Bullet point 2
- Bullet point 3

## Follow-up Questions
1. Question 1
2. Question 2
3. Question 3

**IMPORTANT**: Use proper markdown formatting:
- Use ## for section headings
- Use **bold** for emphasis
- Use bullet points (-) for lists
- Use numbered lists (1., 2., 3.) where appropriate
- Add blank lines between sections for readability

Make your answer clear, actionable, and easy to understand.`;

      // Call Gemini API
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent`, {
        method: 'POST',
        headers: {
          'x-goog-api-key': apiKey,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: systemPrompt }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 8192,
          },
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('API Error Response:', errorData);

        if (response.status === 429) {
          throw new Error('Rate limit exceeded. Please try again later or upgrade your plan.');
        } else if (response.status === 401 || response.status === 403) {
          throw new Error('Invalid API key. Please check and try again.');
        } else if (response.status === 404) {
          throw new Error('API endpoint not found. Please contact support.');
        } else if (errorData?.error?.message) {
          throw new Error(errorData.error.message);
        } else {
          throw new Error('Failed to generate answer. Please try again.');
        }
      }

      const data = await response.json();
      console.log('API Response:', data);
      console.log('Candidates:', data.candidates);
      console.log('First candidate:', data.candidates?.[0]);
      console.log('Content:', data.candidates?.[0]?.content);
      console.log('Parts:', data.candidates?.[0]?.content?.parts);
      console.log('Text:', data.candidates?.[0]?.content?.parts?.[0]?.text);

      // Check if the response was blocked or filtered
      if (data.candidates?.[0]?.finishReason === 'SAFETY') {
        throw new Error('Response was blocked due to safety filters. Please try rephrasing your question.');
      }

      if (data.candidates?.[0]?.finishReason === 'RECITATION') {
        throw new Error('Response was blocked due to recitation. Please try a different question.');
      }

      // Check if response was truncated due to token limits
      if (data.candidates?.[0]?.finishReason === 'MAX_TOKENS') {
        console.warn('Response truncated due to MAX_TOKENS. Full response:', JSON.stringify(data, null, 2));
        throw new Error('Response was truncated due to length limits. Please try a shorter question or simpler prompt.');
      }

      // Check if parts array is missing
      if (!data.candidates?.[0]?.content?.parts) {
        console.error('Missing parts array. Full response:', JSON.stringify(data, null, 2));
        throw new Error('API returned an incomplete response. This may be due to token limits or content filtering. Please try again with a shorter question.');
      }

      const generatedAnswer = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!generatedAnswer) {
        console.error('No text found in response. Full response:', JSON.stringify(data, null, 2));
        throw new Error('No answer generated. The API returned an empty response. Please try again.');
      }

      setAnswer(generatedAnswer);
      
      // If we have a question ID, update the answer in the database
      if (questionId) {
        try {
          await updateQuestionAnswer(parseInt(questionId), {
            text: generatedAnswer,
            model: 'gemini-2.5-pro',
            generated_at: new Date().toISOString()
          });
          
          toast({
            title: 'Success',
            description: 'Answer generated and saved successfully!',
          });
          
          // Update the URL to remove the question ID to prevent duplicate saves on refresh
          navigate(`/interview-questions/practice?category=${encodeURIComponent(selectedCategory)}&question=${encodeURIComponent(question)}`, { replace: true });
        } catch (err) {
          console.error('Error saving answer to database:', err);
          toast({
            title: 'Answer Generated',
            description: 'Answer was generated but could not be saved to the database.',
            variant: 'default',
          });
        }
      } else {
        toast({
          title: 'Answer Generated',
          description: 'Your AI-powered answer is ready!',
        });
      }
    } catch (err: any) {
      console.error('Error generating answer:', err);
      setError(err.message || 'Failed to generate answer. Please try again.');
      
      toast({
        title: 'Error',
        description: err.message || 'Failed to generate answer. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [question, selectedCategory, searchParams, navigate, toast]);

  const copyAnswer = useCallback(() => {
    if (answer) {
      navigator.clipboard.writeText(answer);
      toast({
        title: 'Copied to clipboard',
        description: 'Answer copied to clipboard!',
      });
    }
  }, [answer, toast]);

  const askAnotherQuestion = useCallback(() => {
    setAnswer(null);
    setQuestion('');
    setError(null);
  }, []);

  return (
    <div className="min-h-screen bg-background">
      <SEO
        title="Practice PM Interview Questions | Stare"
        description="Practice answering product management interview questions with AI feedback"
        keywords="PM interview practice, product manager interview prep, mock PM interview, AI interview practice"
        url="/interview-questions/practice"
      />
      <Navbar />
      <main className="container mx-auto px-4 py-8 max-w-4xl">
        <div className="space-y-6">
          <div className="flex items-center justify-between">
            <h1 className="text-3xl font-bold tracking-tight">Interview Question Practice</h1>
            <Button 
              variant="outline" 
              onClick={() => navigate(-1)}
              className="flex items-center gap-2"
            >
              <ArrowLeft className="h-4 w-4" />
              Back
            </Button>
          </div>

          {showApiKeyInput && (
            <Card>
              <CardHeader>
                <CardTitle>Enter Your Gemini API Key</CardTitle>
                <CardDescription>
                  You need a Gemini API key to use this feature. Get one from{' '}
                  <a 
                    href="https://ai.google.dev/" 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-primary hover:underline"
                  >
                    Google AI Studio
                  </a>.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="api-key">API Key</Label>
                  <Input
                    id="api-key"
                    type="password"
                    value={apiKey}
                    onChange={(e) => setApiKey(e.target.value)}
                    placeholder="Enter your Gemini API key"
                    className="font-mono"
                  />
                </div>
                <div className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    id="remember-key"
                    checked={rememberKey}
                    onChange={(e) => setRememberKey(e.target.checked)}
                    className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
                  />
                  <Label htmlFor="remember-key" className="text-sm font-medium">
                    Remember my API key
                  </Label>
                </div>
                <Button 
                  onClick={handleVerifyClick}
                  disabled={!apiKey || isVerifying}
                  className="w-full sm:w-auto"
                >
                  {isVerifying ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Verifying...
                    </>
                  ) : 'Verify API Key'}
                </Button>
              </CardContent>
            </Card>
          )}

          {!showApiKeyInput && (
            <Card>
              <CardHeader>
                <CardTitle>Practice Interview Questions</CardTitle>
                <CardDescription>
                  Enter a product management interview question and get AI-powered feedback.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="category">Category</Label>
                  <Select
                    value={selectedCategory || 'select-category'}
                    onValueChange={(value) => setSelectedCategory(value === 'select-category' ? '' : value)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select a category" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="select-category">Select a category</SelectItem>
                      {categories.map((category) => (
                        <SelectItem key={category.id} value={category.name}>
                          {category.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="question">Question</Label>
                  <Textarea
                    id="question"
                    value={question}
                    onChange={(e) => setQuestion(e.target.value)}
                    placeholder="Enter your interview question here..."
                    className="min-h-[120px]"
                  />
                  <div className="text-sm text-muted-foreground">
                    {question.length}/{CHARACTER_LIMIT} characters
                  </div>
                </div>

                {error && (
                  <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertTitle>Error</AlertTitle>
                    <AlertDescription>{error}</AlertDescription>
                  </Alert>
                )}

                <div className="flex flex-col sm:flex-row gap-2">
                  <Button 
                    onClick={askAI} 
                    disabled={isLoading || !selectedCategory || !question.trim()}
                    className="flex-1"
                  >
                    {isLoading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Generating...
                      </>
                    ) : (
                      <>
                        <Sparkles className="mr-2 h-4 w-4" />
                        Generate Answer
                      </>
                    )}
                  </Button>
                  
                  <Button 
                    variant="outline" 
                    onClick={askAnotherQuestion}
                    disabled={!question && !answer}
                    className="flex-1"
                  >
                    <RotateCcw className="mr-2 h-4 w-4" />
                    New Question
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}

          {answer && (
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle>AI-Generated Answer</CardTitle>
                  <Button 
                    variant="outline" 
                    size="sm" 
                    onClick={copyAnswer}
                    className="gap-2"
                  >
                    <Copy className="h-4 w-4" />
                    Copy
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                <div className="prose dark:prose-invert max-w-none">
                  <ReactMarkdown>{answer}</ReactMarkdown>
                </div>
              </CardContent>
            </Card>
          )}

          <div className="mt-8 bg-muted/30 rounded-lg border border-border/50 p-6">
            <h3 className="text-lg font-medium mb-3">Tips for Better Answers</h3>
            <ul className="space-y-2 text-muted-foreground text-sm">
              <li>• Be specific with your questions for more targeted answers</li>
              <li>• Select the appropriate category to get framework-specific guidance</li>
              <li>• Use the generated answers as a starting point and personalize them</li>
              <li>• Practice articulating the answers out loud to build confidence</li>
            </ul>
            <Button 
              variant="outline" 
              onClick={() => navigate('/interview-questions')}
              className="mt-4"
            >
              Browse Sample Questions
            </Button>
          </div>
        </div>
      </main>
      <Footer />
    </div>
  );
};

export default InterviewQuestionsPractice;
